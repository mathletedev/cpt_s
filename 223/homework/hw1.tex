\documentclass[12pt]{article}
\usepackage[fleqn]{amsmath}
\usepackage{amsthm,amsfonts,amssymb,braket,enumitem,minted}
\newtheorem{thm}{Theorem}
\newenvironment{solution}
{\renewcommand\qedsymbol{$\blacksquare$}
\begin{proof}[Solution]}
  {
\end{proof}}

\begin{document}

\begin{center}
  {\Large CPT\_S 223 Homework 1}
  $ $\\
  $ $\\
  \begin{tabular}{rl}
    WSU ID: & 11870028 \\
    Name: & Neal Wang \\
    Due Date: & 16 February 2025
  \end{tabular}
\end{center}

\section*{Problem 1}

\begin{thm}
  If $N(k)$ is the number of nodes of a complete binary tree at level
  $k$, then $N(k) = 2^k$.
\end{thm}

\begin{proof}
  $ $\\
  Base case: If $k = 0$, then $N(0) = 1$. \\
  Inductive case: Each node has exactly two children
  \begin{align*}
    N(k) & = 2N(k - 1) \\
    & = 2 \cdot 2N(k - 2) \\
    & = 2^mN(k - m) \\
    & = 2^kN(k - k) \\
    & = 2^kN(0) \\
    & = 2^k \cdot 1 \\
    & = 2^k
  \end{align*}
  Therefore, $N(k) = 2^k$.
\end{proof}

\section*{Problem 2}

\begin{minted}{cpp}
int height(Node *p_node, int h = 0) {
  if (p_node == nullptr) {
    return h;
  }

  return std::max(height(p_node->left, h + 1), height(p_node->right, h + 1));
}
\end{minted}

\section*{Problem 3}

\[
  T(n) =
  \begin{cases}
    3, & n = 1 \\
    3T(n / 3) + n, & n > 1 \land n \in \set{n \mid n = 3^k, k \in \mathbb N}
  \end{cases}
\]

\begin{solution}
  \begin{align*}
    T(n) & = 3T\left(\dfrac{n}{3}\right) + n \\
    & = 3 \cdot \left(3T\left(\dfrac{n}{3 \cdot 3}\right) + n / 3\right) + n \\
    & = 3 \cdot 3T\left(\dfrac{n}{3 \cdot 3}\right) + n + n \\
    & = 3^kT\left(\dfrac{n}{3^k}\right) + kn \\
    & = 3^{\log_3 n}T\left(\dfrac{n}{3^{\log_3 n}}\right) + \log_3 n \cdot n \\
    & = nT\left(\dfrac{n}{n}\right) + n \log_3 n \\
    & = nT(1) + n \log_3 n \\
    & = 3n + n \log_3 n \\
  \end{align*}
  Therefore, $T(n) = n \log_3 n + 3n$.
\end{solution}

\section*{Problem 4}

\begin{enumerate}[label=(\alph*)]
  \item
    \begin{enumerate}[label=(\roman*)]
      \item Lambda expressions and \verb|<functional>|: Introduced
        functional programming paradigm.
      \item \verb|nullptr|: A strongly-typed null pointer that
        replaced the bug-prone \verb|NULL| macro.
    \end{enumerate}
  \item How C++ handles null pointers:
    \begin{minted}{cpp}
int square(int x) { return x * x; }
square(NULL); // bad: implicit conversion, may cause ub
square(nullptr); // good: causes compile error
    \end{minted}
  \item C++ 14 introduced generic lambdas, which allow for the use of
    \verb|auto| in lambda function parameters.
\end{enumerate}

\end{document}
